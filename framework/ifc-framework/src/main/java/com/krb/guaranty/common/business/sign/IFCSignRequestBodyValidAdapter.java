package com.krb.guaranty.common.business.sign;import com.krb.guaranty.common.context.IFCInit;import com.krb.guaranty.common.framework.exception.ValidException;import com.krb.guaranty.common.framework.mvc.utils.OursCoreAssert;import lombok.extern.slf4j.Slf4j;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.core.MethodParameter;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpInputMessage;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.http.converter.json.MappingJacksonInputMessage;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.servlet.mvc.method.annotation.RequestBodyAdviceAdapter;import java.io.IOException;import java.lang.reflect.Type;import java.util.HashMap;import java.util.Map;@Slf4j@ControllerAdvicepublic class IFCSignRequestBodyValidAdapter extends RequestBodyAdviceAdapter implements IFCInit {    @Autowired    private IFCSignRequestBodyProperties ifcSignRequestBodyProperties;    private final Map<String,String> keys = new HashMap<>();    @Override    public boolean supports(MethodParameter methodParameter, Type type, Class<? extends HttpMessageConverter<?>> aClass) {        return methodParameter.hasMethodAnnotation(IFCSignRequestBodyValid.class) || methodParameter.getDeclaringClass().isAnnotationPresent(IFCSignRequestBodyValid.class);    }    @Override    public HttpInputMessage beforeBodyRead(HttpInputMessage httpInputMessage, MethodParameter methodParameter, Type type, Class<? extends HttpMessageConverter<?>> aClass) throws ValidException {        if(ifcSignRequestBodyProperties.isSkip()){            return httpInputMessage;        }        IFCSignRequestBodyValid signAnnotation = methodParameter.getMethodAnnotation(IFCSignRequestBodyValid.class);        if(signAnnotation == null){            signAnnotation = methodParameter.getDeclaringClass().getAnnotation(IFCSignRequestBodyValid.class);        }        HttpHeaders headers = httpInputMessage.getHeaders();        String app = StringUtils.isNotEmpty(signAnnotation.app())?signAnnotation.app():headers.getFirst(IFCSignConstants.APP_KEY);        String sign = headers.getFirst(IFCSignConstants.SIGN_KEY);        String requestNo = headers.getFirst(IFCSignConstants.REQUEST_NO_KEY);        OursCoreAssert.notNull(app,"[非法请求，请求体header中缺少"+IFCSignConstants.SIGN_KEY+"]");        OursCoreAssert.notNull(sign,"[非法请求，请求体header中缺少"+IFCSignConstants.APP_KEY+"]");        OursCoreAssert.notNull(requestNo,"[非法请求，请求体header中缺少"+IFCSignConstants.REQUEST_NO_KEY+"]");        String key = StringUtils.isNotEmpty(signAnnotation.key())?signAnnotation.key():keys.get(app);        if(StringUtils.isEmpty(key)){            throw new IFCSignException("[非法请求，未知的"+IFCSignConstants.APP_KEY+":"+app+"]");        }        String bodyString = null;        try {            bodyString = IOUtils.toString(httpInputMessage.getBody());        } catch (IOException e) {            e.printStackTrace();        }        String compareSign = IFCSignUtil.sign(bodyString, key);        log.debug("{}:{},compare:{},bodyString:{}",IFCSignConstants.SIGN_KEY, sign,compareSign,bodyString);        if(!sign.equals(compareSign)){            throw new IFCSignException("[非法请求,鉴权失败]");        }        //因为要对body做鉴权所以需要重新写入一个流        //MappingJacksonInputMessage: 找了个能用的        return new MappingJacksonInputMessage(IOUtils.toInputStream(bodyString),headers);    }    @Override    public void doInit(ApplicationContext application) throws Exception {        if(ifcSignRequestBodyProperties.getKeys() != null){            for (IFCSignAppKey appKey : ifcSignRequestBodyProperties.getKeys()) {                keys.put(appKey.getApp(),appKey.getKey());            }        }    }}